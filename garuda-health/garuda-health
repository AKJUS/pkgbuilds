#!/usr/bin/env python3

import os
from pathlib import Path
import pty
import re
import sys
import subprocess
import argparse
import json
from enum import Enum, auto
import time
from typing import Callable, Optional, List, Dict, NamedTuple, Set, Tuple, TypeAlias
import typing
from dataclasses import dataclass

# -- ANSI color codes --
COLORS = {
    "CRITICAL": "\033[91m", "HIGH": "\033[31m", "LOW": "\033[33m",
    "INFO": "\033[34m", "RESET": "\033[0m", "GREEN": "\033[32m",
}


# -- Core data structures --
Fixer = typing.NewType("Fixer", None)

class Severity(Enum):
    """Defines the 4 categories of issues"""
    INFO = auto()
    LOW = auto()
    HIGH = auto()
    CRITICAL = auto()

@dataclass
class PackageInfo():
    installed: bool; provided: bool

class Issue:
    """
    Represents a specific problem.

    :ivar description: A human-readable string explaining the issue.
    :ivar details: A dictionary to pass context from check to fix.
    :ivar fix: A Fixer object that can be used to fix the issue.
    """
    def __init__(self,
                 description: str,
                 details: Optional[Dict] = None,
                 fix: Optional[Fixer] = None):
        self.description = description
        self.details = details or {}
        self.fix = fix

    def get_summary(self) -> str:
        return self.description

class HealthCheckResult(NamedTuple):
    severity: Severity
    issue: Issue

class HealthCheck:
    """
    Wrapper for a health check function.
    """
    def __init__(self, check_callable: Callable[[], Optional[HealthCheckResult]], packages: Optional[List[str]] = None):
        """
        :param check_callable: A function that performs a health check and returns a HealthCheckResult or None (if no issue was found).
        """
        self.check_callable = check_callable
        if packages:
            cache.add(packages)

    def run(self) -> Optional[HealthCheckResult]:
        """
        Execute the check callable and return its result directly.

        :return: A HealthCheckResult if an issue is found, otherwise None.
        """
        return self.check_callable()

class PackageCache:
    """
    A simple cache to store package existence checks.
    """
    def __init__(self):
        self.cache: Dict[str, PackageInfo] = {}
        self.pending: Set[str] = set()

    def add(self, packages: List[str]):
        """
        Ask for a list of packages to be checked.

        :param packages: A list of package names to cache.
        """
        self.pending.update(packages)

    def get(self, package_name: str) -> Optional[PackageInfo]:
        """
        Get the cached PackageInfo for a package name.

        :param package_name: The name of the package to retrieve.
        :return: A PackageInfo object if found, otherwise None.
        """
        return self.cache.get(package_name)

    def execute(self) -> None:
        """
        Execute the cache, checking all pending packages.
        This should be called before any checks that require package existence.
        """
        self.cache.clear()
        if not self.pending:
            return

        packages = " ".join(self.pending)
        result = run_shell_command(f"LANG=C LANGUAGE=C LC_ALL=C pacman -Qq {packages}")

        if result.exit_code != 0 and result.exit_code != 1:
            raise Exception(f"Failed to check package existence with pacman: {result.stderr}")

        for package_name in self.pending:
            self.cache[package_name] = PackageInfo(
                installed=True,
                provided=True,
            )

        regex_pattern = re.compile(f"^error: package '([^']+)' was not found$")

        for line in result.stderr.splitlines():
            if match := regex_pattern.match(line):
                package_name = match.group(1)
                self.cache[package_name].installed = False

        for line in result.stdout.splitlines():
            name = line.strip()
            if name in self.cache:
                self.cache[name].provided = False

class Fixer:
    """A class to encapsulate a fix action, its priority, and other metadata."""

    def __init__(
        self,
        fix_function: Callable[[Issue], Tuple[bool, str]],
        priority: int = 5,
        excludes: List[str] = None,
        actions: List[str] = None,
    ):
        self.fix_function = fix_function
        self.priority = priority
        self.excludes = excludes if excludes is not None else []
        self.actions = (actions if actions is not None else [])

    def fix(self, issue: Issue) -> Tuple[bool, str]:
        return self.fix_function(issue)

class ShellResult(NamedTuple):
    exit_code: int; stdout: str; stderr: str

class SystemdStatus(NamedTuple):
    active_state: str; is_enabled: bool

# -- Convenience Functions --

cache = PackageCache()

def run_shell_command(command: str, timeout: int = 10) -> ShellResult:
    """
    Run a command in a bash shell and capture its output.

    :param command: The shell command string to execute.
    :param timeout: The maximum time to wait for a command to complete.
    :return: A ShellResult object containing the exit code, stdout, and stderr.
    """
    try:
        process = subprocess.run(
            ['/bin/bash', '-c', command],
            capture_output=True, text=True, timeout=timeout, check=False
        )
        return ShellResult(process.returncode, process.stdout.strip(), process.stderr.strip())
    except FileNotFoundError:
        return ShellResult(127, "", "Shell (/bin/bash) not found.")
    except subprocess.TimeoutExpired:
        return ShellResult(124, "", f"Command timed out after {timeout} seconds.")

def get_systemd_service_status(service_name: str) -> Optional[SystemdStatus]:
    """
    Check the status and enablement state of a systemd service.

    :param service_name: The name of the service (e.g., "sshd.service").
    :return: A SystemdStatus object if the service is found, otherwise None.
    """
    exists_result = run_shell_command(f"systemctl list-unit-files {service_name}")
    if exists_result.exit_code != 0:
        return None  # Service does not exist
    active_result = run_shell_command(f"systemctl is-active {service_name}")
    enabled_result = run_shell_command(f"systemctl is-enabled {service_name}")
    return SystemdStatus(active_result.stdout, enabled_result.exit_code == 0)
      
def run_interactive_command(command: str, require_consent: bool = False) -> int:
    """
    Runs a command in a bash shell inside a pseudo-terminal (pty).

    This is the ideal way to run programs that require user interaction, have complex UIs.
    For example: pacman.

    :param command: The command string to execute in the bash shell.
    :param require_consent: If True, prompt the user for [y/N] confirmation
                            before running the command. Defaults to False.
    :return: The integer exit code of the command.
             - Returns 130 if the user cancels at the consent prompt.
             - Returns 127 if /bin/bash is not found.
             - Returns 1 for other errors during execution.
    """
    if require_consent:
        print(f"{COLORS['LOW']}The following command will be executed:{COLORS['RESET']}")
        print(f"  {command}")
        
        try:
            user_input = input("Continue? [y/N]: ")
        except (KeyboardInterrupt, EOFError):
            return 130

        if user_input.strip().lower() != 'y':
            print("Operation cancelled by user.")
            return 130

    argv = ['/bin/bash', '-c', command]
    
    try:
        wait_status = pty.spawn(argv)
    except FileNotFoundError:
        return 127
    except Exception as e:
        print(f"{COLORS['CRITICAL']}--- An error occurred: {e} ---{COLORS['RESET']}", file=sys.stderr)
        return 1
    
    if os.WIFEXITED(wait_status):
        exit_code = os.WEXITSTATUS(wait_status)
        return exit_code
    else:
        return 1

# -- Fix Functions --

def _fix_enable_services(issue: Issue) -> Tuple[bool, str]:
    """
    Generic fix to enable a systemd service.

    :param issue: The Issue object containing details about the service.
    :return: A tuple of (success_boolean, status_message).
    """
    services = issue.details.get("services")

    if not services:
        return False, "No services provided to enable."
    for service in services:
        result = run_interactive_command(f"systemctl enable {service}", require_consent=True)
        if result != 0:
            return False, f"Failed to enable service {service}. Exit code: {result}"
    return True, f"Enabled services: {', '.join(services)} successfully."

fix_enable_services = Fixer(fix_function=_fix_enable_services, priority=1)


def _fix_pacman_conf(issue: Issue) -> Tuple[bool, str]:
    """
    Fix the pacman configuration by running a remote fix command.

    :param issue: The Issue object containing details about the pacman configuration.
    :return: A tuple of (success_boolean, status_message).
    """
    result = run_interactive_command("garuda-update remote fix", require_consent=True)
    if result == 0:
        return True, "Pacman configuration fixed successfully."
    elif result == 130:
        return False, "Fix cancelled by user."
    else:
        return False, f"Failed to fix pacman configuration. Exit code: {result}"

fix_pacman_conf = Fixer(fix_function=_fix_pacman_conf, priority=9, excludes=["pacman_conf", "update"], actions=["pacman_conf", "update"])


def _fix_install_nvidia_drivers(issue: Issue) -> Tuple[bool, str]:
    """
    Install the nvidia drivers using garuda-hardware-tool.

    :param issue: The Issue object
    :return: A tuple of (success_boolean, status_message).
    """
    result = run_interactive_command("garuda-hardware-tool --nonfree", require_consent=True)
    if result == 0:
        return True, "Nvidia drivers installed successfully. Please reboot your system."
    elif result == 130:
        return False, "Fix cancelled by user."
    else:
        return False, f"Failed to install nvidia drivers. Exit code: {result}"

fix_install_nvidia_drivers = Fixer(fix_function=_fix_install_nvidia_drivers, priority=7)

def _fix_install_packages(issue: Issue) -> Tuple[bool, str]:
    """
    Install missing packages using pacman.

    :param issue: The Issue object containing details about the missing packages.
    :return: A tuple of (success_boolean, status_message).
    """
    packages = issue.details.get("packages")
    if not packages:
        return False, "No packages provided to install."

    package_list = " ".join(packages)
    result = run_interactive_command(f"sudo pacman -S {package_list}", require_consent=True)
    if result == 0:
        return True, f"Installed packages: {package_list} successfully."
    elif result == 130:
        return False, "Fix cancelled by user."
    else:
        return False, f"Failed to install packages. Exit code: {result}"

fix_install_packages = Fixer(fix_function=_fix_install_packages, priority=7, excludes=["install"], actions=["install"])

def _fix_update_system(issue: Issue) -> Tuple[bool, str]:
    """
    Update the system using garuda-update.

    :param issue: The Issue object
    :return: A tuple of (success_boolean, status_message).
    """
    result = run_interactive_command("garuda-update", require_consent=False)
    if result == 0:
        return True, "System updated successfully."
    elif result == 130:
        return False, "Fix cancelled by user."
    else:
        return False, f"Failed to update system. Exit code: {result}"

fix_update_system = Fixer(fix_function=_fix_update_system, priority=8, excludes=["update"], actions=["update"])

def _fix_remove_old_btrfs_snapshots(issue: Issue) -> Tuple[bool, str]:
    """
    Remove old Btrfs snapshots using snapper-tools.

    :param issue: The Issue object
    :return: A tuple of (success_boolean, status_message).
    """
    result = run_interactive_command("sudo snapper-tools delete-old", require_consent=True)
    if result == 0:
        return True, "Old Btrfs snapshots removed successfully."
    elif result == 130:
        return False, "Fix cancelled by user."
    else:
        return False, f"Failed to remove old Btrfs snapshots. Exit code: {result}"

fix_remove_old_btrfs_snapshots = Fixer(fix_function=_fix_remove_old_btrfs_snapshots, priority=1)

# -- Check Implementations --

def check_for_packages(severity: Severity, package_names: List[str], package_names_providable: List[str], text: str) -> Optional[HealthCheckResult]:
    """
    Check if garuda linux packages are installed.

    :param severity: The severity level for the check.
    :param package_names: A list of package names to check.
    :return: A HealthCheckResult if any package is missing, otherwise None.
    """
    missing_packages = [pkg for pkg in package_names if not ((pkg_info := cache.get(pkg)).installed and not pkg_info.provided)]
    missing_packages += [pkg for pkg in package_names_providable if not ((pkg_info := cache.get(pkg)).installed)]
    
    if missing_packages:
        return HealthCheckResult(
            severity,
            Issue(
                f"{text}: {', '.join(missing_packages)}",
                fix=None
            )
        )
    return None

def check_for_core_packages() -> HealthCheck:
    """
    Check if core garuda linux packages are installed.

    :return: A HealthCheckResult if a core package is missing, otherwise None.
    """
    core_packages = ["base", "chaotic-keyring", "chaotic-mirrorlist"]
    def check() -> Optional[HealthCheckResult]:
        return check_for_packages(
            Severity.CRITICAL, core_packages, [], "Core garuda linux packages are missing"
        )
    return HealthCheck(check, core_packages)

def check_for_important_packages() -> HealthCheck:
    """
    Check if important garuda linux packages are installed.

    :return: A HealthCheckResult if an important package is missing, otherwise None.
    """
    important_packages = ["garuda-common-settings", "garuda-hotfixes", "garuda-update", "garuda-libs"]
    def check() -> Optional[HealthCheckResult]:
        return check_for_packages(
            Severity.HIGH, important_packages, [], "Important garuda linux packages are missing"
        )
    return HealthCheck(check, important_packages)

def check_for_optional_packages() -> HealthCheck:
    """
    Check if optional garuda linux packages are installed.

    :return: A HealthCheckResult if an optional package is missing, otherwise None.
    """
    optional_packages = ["garuda-rani", "garuda-hardware-tool", "garuda-system-maintenance"]
    def check() -> Optional[HealthCheckResult]:
        return check_for_packages(
            Severity.INFO, [], optional_packages, "Optional garuda linux utilities are missing"
        )
    return HealthCheck(check, optional_packages)

def check_pacman_conf() -> HealthCheck:
    """
    Check if the pacman configuration file exists and has all the correct repositories.

    :return: A HealthCheckResult if the configuration is missing or incorrect, otherwise None.
    """
    def check() -> Optional[HealthCheckResult]:
        pacman_conf_path = "/etc/pacman.conf"
        if not os.path.exists(pacman_conf_path):
            return HealthCheckResult(
                Severity.CRITICAL,
                Issue(
                    "Pacman configuration file is missing",
                    fix=fix_pacman_conf
                )
            )

        found_repos = set()
        # Check if the file contains the required repositories
        with open(pacman_conf_path, 'r') as f:
            for line in f:
                stripped_line = line.strip()
                if stripped_line.startswith('[') and stripped_line.endswith(']'):
                    found_repos.add(stripped_line)
        required_repos = ["[garuda]", "[core]", "[extra]", "[chaotic-aur]"]
        if not all(repo in found_repos for repo in required_repos):
            return HealthCheckResult(
                Severity.CRITICAL,
                Issue(
                    "Pacman configuration file is missing required repositories",
                    fix=fix_pacman_conf
                )
            )
        if not any(repo == "[multilib]" for repo in found_repos):
            return HealthCheckResult(
                Severity.INFO,
                Issue(
                    "Pacman configuration file does not have the multilib repository enabled",
                    fix=None
                )
            )
        return None
    return HealthCheck(check, [])

def check_nvidia_drivers() -> HealthCheck:
    """
    Check if nvidia drivers are installed.

    :return: A HealthCheckResult if proprietary drivers are missing, otherwise None.
    """
    def check() -> Optional[HealthCheckResult]:
        if not os.path.exists("/usr/bin/garuda-hardware-tool"):
            return None
        result = run_shell_command("garuda-hardware-tool --nonfree --check")
        if result.exit_code != 0:
            return None
        if "nvidia" in result.stdout.lower():
            if cache.get("NVIDIA-MODULE").installed:
                return HealthCheckResult(
                    Severity.INFO,
                    Issue(
                        "Nvidia drivers are installed, but no/the incorrect/subobptimal hardware profile is active",
                        fix=fix_install_nvidia_drivers
                    )
                )
            else:
                return HealthCheckResult(
                    Severity.INFO,
                    Issue(
                        "Nvidia drivers are not installed",
                        fix=fix_install_nvidia_drivers
                    )
                )

        return None
    return HealthCheck(check, ["NVIDIA-MODULE"])

def check_nvidia_kernel_module() -> HealthCheck:
    """
    Check if the nvidia kernel module is loaded.

    :return: A HealthCheckResult if the nvidia kernel module is not loaded, otherwise None.
    """
    def check() -> Optional[HealthCheckResult]:
        if cache.get("NVIDIA-MODULE").installed:
            # Check if "nvidia" kernel module is loaded
            if not os.path.exists("/sys/module/nvidia/"):
                return HealthCheckResult(
                    Severity.HIGH,
                    Issue(
                        "Nvidia kernel module is not loaded",
                        fix=None
                    )
                )
        return None
    return HealthCheck(check, ["NVIDIA-MODULE"])

def check_btrfs_root_storage() -> HealthCheck:
    """
    Check if the root filesystem is using Btrfs and has enough free space.

    :return: A HealthCheckResult if the root filesystem is not Btrfs, otherwise None.
    """
    def check() -> Optional[HealthCheckResult]:
        if (not os.path.exists("/usr/bin/btrfs")):
            return None

        # Check free space
        free_space_result = run_shell_command("btrfs filesystem usage / -m --si")
        if free_space_result.exit_code != 0:
            return None
        # Find Overall -> Device unallocated:
        match = re.search(r"\s+Device unallocated:\s+(\d+)\.\d+MB", free_space_result.stdout)
        if match:
            free_space_mb = int(match.group(1))
            if free_space_mb < 3000:  # Less than 5GB free space
                return HealthCheckResult(
                    Severity.HIGH,
                    Issue(
                        "Root Btrfs filesystem has less than 5GB free space",
                        fix=None
                    )
                )
            elif free_space_mb < 10000:  # Less than 10GB free space
                return HealthCheckResult(
                    Severity.LOW,
                    Issue(
                        "Root Btrfs filesystem has less than 10GB free space",
                        fix=None
                    )
                )

        return None
    return HealthCheck(check, [])

def check_btrfs_timers() -> HealthCheck:
    """
    Check if the Btrfs maintenance timers are enabled.

    :return: A HealthCheckResult if the btrfs maintenance services are not running or enabled, otherwise None.
    """
    def check() -> Optional[HealthCheckResult]:
        services = ["btrfs-scrub.timer", "btrfs-balance.timer", "btrfs-defrag.timer"]
        missing_services = []
        for service in services:
            status = get_systemd_service_status(service)
            if not status:
                continue
            if status.is_enabled is False:
                missing_services.append(service)

        if missing_services:
            issue_description = "Btrfs maintenance timers are not enabled: " + ", ".join(missing_services)
            return HealthCheckResult(
                Severity.LOW,
                Issue(
                    issue_description,
                    details={"services": missing_services},
                    fix=fix_enable_services
                )
            )
        return None
    return HealthCheck(check, [])

def check_using_dracut() -> HealthCheck:
    """
    Check if the system is using dracut for initramfs.

    :return: A HealthCheckResult if dracut is not being used, otherwise None.
    """
    def check() -> Optional[HealthCheckResult]:
        if not ((pkg := cache.get("dracut")).installed):
            return HealthCheckResult(
                Severity.INFO,
                Issue(
                    "System is not using dracut for initramfs",
                    fix=fix_install_packages,
                    details={"packages": ["garuda-dracut-support"]}
                )
            )
        if not ((pkg := cache.get("garuda-dracut-support")).installed and not pkg.provided):
            return HealthCheckResult(
                Severity.HIGH,
                Issue(
                    "System is using dracut, but garuda-dracut-support is not installed",
                    fix=fix_install_packages,
                    details={"packages": ["garuda-dracut-support"]}
                )
            )
        return None
    return HealthCheck(check, ["dracut", "garuda-dracut-support"])

def check_using_pipewire() -> HealthCheck:
    """
    Check if the system is using PipeWire for audio.

    :return: A HealthCheckResult if PipeWire is not being used, otherwise None.
    """
    def check() -> Optional[HealthCheckResult]:
        if not ((pkg := cache.get("pipewire")).installed):
            return HealthCheckResult(
                Severity.INFO,
                Issue(
                    "System is not using PipeWire for audio",
                    fix=fix_install_packages,
                    details={"packages": ["pipewire-support"]}
                )
            )

        if not ((pkg := cache.get("pipewire-support")).installed and not pkg.provided):
            return HealthCheckResult(
                Severity.INFO,
                Issue(
                    "System is using PipeWire, but pipewire-support is not installed",
                    fix=fix_install_packages,
                    details={"packages": ["pipewire-support"]}
                )
            )
        return None
    return HealthCheck(check, ["pipewire", "pipewire-support"])

def check_partial_upgrade() -> HealthCheck:
    """
    Check if the system is partially upgraded.

    :return: A HealthCheckResult if the system is partially upgraded, otherwise None.
    """
    def check() -> Optional[HealthCheckResult]:
        partial_upgrade_file = "/var/lib/garuda/partial_upgrade"

        if os.path.exists(partial_upgrade_file):
            return HealthCheckResult(
                Severity.CRITICAL,
                Issue(
                    "System is partially upgraded",
                    fix=fix_update_system
                )
            )
        return None
    return HealthCheck(check, [])

def check_outdated_system() -> HealthCheck:
    """
    Check if the system is outdated. (older than 2 weeks)

    :return: A HealthCheckResult if the system is outdated, otherwise None.
    """
    def check() -> Optional[HealthCheckResult]:
        last_update_file = "/var/lib/garuda/last_update"
        # File timestamp is the date of the last update
        if not os.path.exists(last_update_file):
            return None
        last_update_time = os.path.getmtime(last_update_file)
        current_time = time.time()
        # Check if the last update was more than 2 weeks ago
        if (current_time - last_update_time) > (14 * 24 * 60 * 60):  # 2 weeks in seconds
            return HealthCheckResult(
                Severity.HIGH,
                Issue(
                    "System is outdated (last update more than 2 weeks ago)",
                    fix=fix_update_system
                )
            )
        return None
    return HealthCheck(check, [])

def check_pending_reboot() -> HealthCheck:
    """
    Check if a reboot is pending.

    :return: A HealthCheckResult if a reboot is pending, otherwise None.
    """
    def check() -> Optional[HealthCheckResult]:
        # Check if last update is newer than the last reboot
        last_update_file = "/var/lib/garuda/last_update"
        last_reboot_benchmark = "/proc"

        if not os.path.exists(last_update_file):
            return None

        last_update_time = os.path.getmtime(last_update_file)
        last_reboot_time = os.path.getctime(last_reboot_benchmark)

        if last_update_time > last_reboot_time:
            return HealthCheckResult(
                Severity.INFO,
                Issue(
                    "A reboot is pending (update applied since last reboot)",
                    fix=None
                )
            )
        return None
    return HealthCheck(check, [])

def check_failed_systemd_services() -> HealthCheck:
    """
    Check for failed systemd services.

    :return: A HealthCheckResult if any failed services are found, otherwise None.
    """
    def check() -> Optional[HealthCheckResult]:
        result = run_shell_command("systemctl list-units --failed --full --all --plain --no-legend")
        if result.exit_code != 0 or not result.stdout.strip():
            return None  # No failed services

        failed_services = []
        for line in result.stdout.strip().splitlines():
            failed_services.append(line.split()[0])

        if failed_services:
            return HealthCheckResult(
                Severity.CRITICAL,
                Issue(
                    "Failed systemd services found: " + ", ".join(failed_services),
                    details={"services": failed_services},
                    fix=fix_enable_services
                )
            )
        return None
    return HealthCheck(check, [])

def check_has_old_btrfs_snapshots() -> HealthCheck:
    """
    Check if there are old Btrfs snapshots that can be deleted.

    :return: A HealthCheckResult if old snapshots are found, otherwise None.
    """
    def check() -> Optional[HealthCheckResult]:
        if not os.path.exists("/usr/bin/snapper-tools"):
            return None

        result = run_shell_command("pkexec snapper-tools find-old")
        if result.exit_code == 0:
            return HealthCheckResult(
                Severity.LOW,
                Issue(
                    "Old Btrfs snapshots found that can be deleted",
                    fix=fix_remove_old_btrfs_snapshots
                )
            )
        return None
    return HealthCheck(check, [])

def check_cpu_temperature() -> HealthCheck:
    """
    Check if the CPU temperature is within safe limits.

    :return: A HealthCheckResult if the CPU temperature is too high, otherwise None.
    """
    def check() -> Optional[HealthCheckResult]:
        thermal_zone_path = "/sys/class/thermal/"
        cpu_temp = "x86_pkg_temp"
        try:
            thermal_zones = Path(thermal_zone_path).glob("thermal_zone*")
            if not thermal_zones:
                return None

            for zone in thermal_zones:
                type_file = zone / "type"
                if not type_file.exists():
                    continue
                with open(type_file, 'r') as f:
                    if cpu_temp != f.read().strip():
                        continue
                temp_file = zone / "temp"
                if not temp_file.exists():
                    break
                with open(temp_file, 'r') as f:
                    temp = int(f.read().strip())
                    if temp > 90000:  # Temperature in millidegrees Celsius
                        return HealthCheckResult(
                            Severity.LOW,
                            Issue(
                                f"CPU temperature is too high: {temp / 1000:.1f}°C",
                                fix=None
                            )
                        )
                    else:
                        break
        except (IOError, ValueError):
            return None
        return None
    return HealthCheck(check, [])

checks: List[HealthCheck] = [
    check_for_core_packages(),
    check_for_important_packages(),
    check_for_optional_packages(),
    check_pacman_conf(),
    check_nvidia_drivers(),
    check_nvidia_kernel_module(),
    check_btrfs_root_storage(),
    check_btrfs_timers(),
    check_using_dracut(),
    check_using_pipewire(),
    check_partial_upgrade(),
    check_outdated_system(),
    check_pending_reboot(),
    check_failed_systemd_services(),
    check_has_old_btrfs_snapshots(),
    check_cpu_temperature(),
]

# -- Main Execution Logic --
CheckResults: TypeAlias = Dict[Severity, List[HealthCheckResult]]

def perform_check_run(debug: bool) -> Tuple[bool, CheckResults, float]:
    """
    Run all checks and collect results.

    :return: A tuple containing (has_issues_boolean, results_dictionary).
    """
    # Refresh the package cache
    time_full_start = time.time()
    cache.execute()
    results: CheckResults = {s: [] for s in Severity}
    for check in checks:
        if (debug):
            time_start = time.time()
        try:
            result = check.run()
            if (debug):
                time_end = time.time()
                print(f"Check {check.check_callable.__name__} took {time_end - time_start:.2f} seconds")
            if result:
                results[result.severity].append(result)
        except Exception as e:
            if debug:
                print(f"Error running check {check.check_callable.__name__}: {e}")
                continue
    has_issues = any(results.values())
    time_full = time.time() - time_full_start
    return has_issues, results, time_full

def has_error_level_issues(results: CheckResults) -> bool:
    """
    Check if any issues are of LOW severity or higher.

    :param results: The dictionary of results from perform_check_run.
    :return: True if there are any LOW, HIGH, or CRITICAL issues.
    """
    severities_that_cause_failure = [Severity.LOW, Severity.HIGH, Severity.CRITICAL]
    return any(results[s] for s in severities_that_cause_failure)

def print_text_report(has_issues: bool, results: CheckResults, time) -> None:
    """
    Print a text report to the console based on check results.

    :param has_issues: Boolean indicating if any issues were found.
    :param results: The dictionary of results from perform_check_run.
    """
    print(f"{COLORS['INFO']}--- System Health Check Report ---{COLORS['RESET']}")
    print(f"{COLORS['GREEN']}{len(checks)} checks run in {time:.2f} seconds ⌛{COLORS['RESET']}")
    print(f"{COLORS['GREEN']}Powered by garuda-health 🦅{COLORS['RESET']}")
    if not has_issues:
        print(f"\n✅ System health check passed. No issues found.")
        return

    for severity in reversed(list(Severity)):
        if results[severity]:
            color, reset = COLORS.get(severity.name, ""), COLORS["RESET"]
            print(f"\n{color}--- {severity.name} ---{reset}")
            for res in results[severity]:
                fix_available = " (fix available)" if res.issue.fix else ""
                print(f"  - {res.issue.get_summary()}{fix_available}")

def apply_fixes(results: CheckResults) -> bool:
    """
    Attempt to apply all available fixes for the found issues.

    Fixes are applied in descending order of priority. If a fix succeeds, its
    `excludes` are noted. Subsequent fixes will be skipped if their `actions`
    overlap with any previously noted exclusions.

    :param results: The dictionary of results from perform_check_run.
    :return: True if all fixes ran without exceptions, False otherwise.
    """
    print("\n--- Applying Fixes ---")
    had_errors = False
    excluded_actions: Set[str] = set()

    fixable_results = [
        res for sev_list in results.values()
        for res in sev_list if res.issue.fix is not None
    ]

    fixable_results.sort(key=lambda r: r.issue.fix.priority, reverse=True)

    for result in fixable_results:
        if not excluded_actions.isdisjoint(result.issue.fix.actions):
            continue

        print(f'Fixing "{result.issue.get_summary()}": ', flush=True)
        try:
            success, message = result.issue.fix.fix(result.issue)
            print(message)

            if success:
                if result.issue.fix.excludes:
                    excluded_actions.update(result.issue.fix.excludes)

        except Exception as e:
            print(f"Failed with exception: {e}")
            had_errors = True

    if not fixable_results:
        print("No issues with available fixes were found.")

    return not had_errors

def main():
    """
    Parse arguments, run all checks, and report the results.
    """
    parser = argparse.ArgumentParser(description="A flexible Linux system health checking tool.")
    parser.add_argument('--fix', action='store_true', help="Attempt to fix issues and re-run checks.")
    parser.add_argument('--json', action='store_true', help="Output in JSON. Incompatible with --fix.")
    parser.add_argument('--debug', action='store_true', help="Enable debug output.")
    args = parser.parse_args()

    if not sys.stdout.isatty():
        for key in COLORS: COLORS[key] = ""

    if args.json and args.fix:
        parser.error("--json and --fix are incompatible.")

    ## Demand root when --fix is used
    #if args.fix and os.geteuid() != 0:
    #    print(f"{COLORS['CRITICAL']}Error: --fix requires root privileges.{COLORS['RESET']}")
    #    sys.exit(1)

    has_initial_issues, initial_results, initial_time = perform_check_run(args.debug)
    should_fail_initial = has_error_level_issues(initial_results)

    if args.json:
        json_output = {}
        if has_initial_issues:
            for severity in reversed(list(Severity)):
                if initial_results[severity]:
                    json_output[severity.name] = [
                        {
                            "description": res.issue.get_summary(),
                            "fix_available": res.issue.fix is not None,
                        } for res in initial_results[severity]
                    ]
        print(json.dumps(json_output, indent=2))
        sys.exit(1 if should_fail_initial else 0)

    print_text_report(has_initial_issues, initial_results, initial_time)
    
    final_exit_code = 1 if should_fail_initial else 0

    if args.fix and has_initial_issues:
        fixes_ran_cleanly = apply_fixes(initial_results)
        
        if fixes_ran_cleanly:
            print("\n--- Re-running checks after applying fixes ---")
            has_final_issues, final_results, final_time = perform_check_run(args.debug)
            should_fail_final = has_error_level_issues(final_results)
            
            print_text_report(has_final_issues, final_results, final_time)
            
            final_exit_code = 1 if should_fail_final else 0

    sys.exit(final_exit_code)

if __name__ == "__main__":
    main()